---
title: "Atelier du 16 mars 2023"
subtitle: "Utilisation de modèles de régression à coefficients variant dans le temps dans le cadre de la prévision conjoncturelle"
author:
- Claire du Campe de Rosamel
# TODO : PSE ?
- Alain Quartier-la-Tente
# TODO : logos
format: 
  revealjs:
   smaller: true
   theme: default
   css: css/template.css
fig-height: 7
---

## Introduction

Sur longue période, les institutions, les normes de sociétés ainsi que les comportements des agents économiques évoluent, induisant des changements dans la dynamique des séries économiques étudiées.

. . .

De nombreux modèles de l'Insee sont basés sur des régressions linéaires (CJO, prévisions, calage...) qui supposent que les relations entre les variables sont fixes dans le temps.

. . .

Hypothèse vraie sur le court-terme mais généralement fausse sur le long-terme ou en présence de changements structurels (changement de nomenclature, de définition, COVID...)

## Modèle de régression linéaire

L'idée générale des modèles de régression linéaire est la suivante :

$$
\DeclareMathOperator{\argmin}{argmin}
y_t=\beta_0+\beta_1 x_{1,t}+\dots+\beta_p x_{p,t} +\varepsilon_t 
$$

$$
y_t=\beta X_t+\varepsilon_t
$$

Estimé grâce à la méthode des moindres carrés (sous les hypothèses de Gauss Markov).

. . .

On s'appuira sur un modèle linéaire simple pour illustrer la présentation : l'estimation entre 1990 Q1 et 2019 Q4 du PIB grâce à deux variables explicatives, le climat des affaires et sa différence.

$$
PIB_t = \beta_0 + \beta_1 climat\_fr_t + \beta_2 \Delta climat\_fr_t + \epsilon_t
$$

. . . 

Ce qui nous donne l'estimation suivante : 

$$
PIB_t = -2,09 + 0,02 \times climat\_fr_t + 0,04 \times \Delta climat\_fr_t + \epsilon_t
$$


## 

On peut évaluer la qualité des modèles estimés en comparant leurs residus, et plus directement en calculant les RMSE (root mean square error) :

$$
\sqrt{\frac{\sum_{t=1}^{T} (PIB_t - \widehat{PIB}_t)^2}{T}}
$$

. . . 

On peut aussi s'appuyer sur le test de Diebold Mariano. De la même manière il compare les erreurs de prédiction de deux modèles et si leur différence est significative. 

. . . 

Grâce à ces méthodes on peut comparer les estimations dans l'échantillon, ou en temps réel. 

- Dans l'échantillon : utilise toutes les données disponibles pour estimer les valeurs au sein de l'échantillon. Ce sont les valeurs ajustées qu'on obtient après une régression linéaire. 

. . . 

- En temps réel : S'appuie sur les prévisions hors échantillon qui prévoient des valeurs en dehors d'un échantillon de données. Pour des estimations en temps réel on estime le modèle sur sur un sous ensemble de données, on prévoit une estimation en dehors du modèle, puis on recommence en ajoutant une nouvelle donnée.

## 

```{r}
library(dygraphs)
readRDS("graphs_atelier/plot_pib.RDS")
```

## 

```{r}
readRDS("graphs_atelier/plot_lm.RDS")
```

##

```{r}
readRDS("graphs_atelier/oos_lm.RDS")
```

## 

Notre idée était donc de voir comment on pourrait modéliser et estimer le modèle suivant: 

$$
PIB_t = \beta_{0,t} + \beta_{1,t} climat\_fr_t + \beta_{2,t} \Delta climat\_fr_t + \epsilon_t
$$

Tout en restant sur des modèles proches de la régression linéaire pour que les résultats restent facilement interprétables. 

. . . 

Il s'agira donc de passer en revue les différents modèles que nous avons pu étudier 

1. Les tests statitiques à notre disposition
1. Les régressions par morceaux
1. Les régressions locales
1. Les modèles espace-état
1. Quelques résultats 

## Tests statistiques

On cherche à savoir si les coefficients sont stables au cours du temps. Utilisation de deux tests :

. . .

-   **Bai et Perron (2003)**

Il s'appuie lui même sur le test de Chow. Propose un algorithme efficace pour trouver les dates de ruptures (package `strucchange`). Soit le modèle :

$$
PIB_t = \beta_0 + \beta_1 climat\_fr_t + \beta_2 \Delta climat\_fr_t + \epsilon_t
$$

. . .

On le sépare en deux, autour d'une date $t_1$, et on obtient deux sous-modèles :

$$
\forall t \leq t_1 :\quad PIB_t = \beta_0' + \beta_1' climat\_fr_t + \beta_2' \Delta climat\_fr_t + \epsilon_t
$$

$$
\forall t > t_1 :\quad PIB_t = \beta_0'' + \beta_1'' climat\_fr_t + \beta_2'' \Delta climat\_fr_t + \epsilon_t
$$

L'hypothèse nulle supose que $\beta_0' = \beta_0''$, $\beta_1' = \beta_1''$ et $\beta_2' = \beta_2''$. Autrement dit, on teste si les deux modèles obtenus sont significativement différents.

##

Limites de Bai Perron :

-   La rupture peut n'être que sur un sous-ensemble de variables, mais le test ne s'applique que sur l'ensemble d'un modèle

. . .

On teste :

$$
PIB_t = (\beta_{0} + \beta_{1} climat\_fr_t + \beta_{2} \Delta climat\_fr_t) \mathbb 1_{t \leq t_1} +
\\
(\beta_{0}' + \beta_{1}' climat\_fr_t + \beta_{2}' \Delta climat\_fr_t)\mathbb 1_{t > t_1} +
\epsilon_t
$$

On ne peut pas tester :

$$
PIB_t = \beta_{0} + \beta_{1} climat\_fr_t + (\beta_{2} \mathbb 1_{t \leq t_1}+ \beta_{2}' \mathbb 1_{t > t_1})\Delta climat\_fr_t +
\epsilon_t
$$

. . .

-   Peut détecter une date de rupture là où on aurait plutôt une évolution lente dans le temps et non brutale

. . .

Mais ces tests supposent qu'il existe une date de rupture à déterminer, alors que l'on veut parfois juste savoir si les coefficients sont constants ou non.

##

-   **Nyblom et Hansen**

. . .

Tests trouvés dans la littérature autour de Nyblom et Hansen (1992) : implémentation de ce test dans le package `tvCoef` (`hansen.test`)

TODO ALAIN : hypothèses de test sur Hansen

. . .

Limites de Hansen :

-   Test de la l'instabilité de la variance (passer par d'autres tests)

-   Test joint ne s'applique pas aux indicatrices

- Interprétation constante : peut être donnée comme stable même si une autre variable varie au cours du temps

Comme tout test, ils ont leurs limites, prendre les résultats avec précaution. Ex : même si le test de Hansen ne détecte pas d'instabilité, le test de Bai et Perron peut néanmoins détecter des ruptures.

## Régressions linéaires par morceaux

Modèles les plus simples :

$$
\exists t_1,\dots,t_{T-1}:\:
\beta_t = \beta_1\mathbb 1_{t \leq t_1} + \beta_2 \mathbb 1_{t_1 < t \leq t_2} + \dots + \beta_T \mathbb 1_{t_{T-1} < t}
$$

. . .

S'estime en découpant les régresseurs ($\mathbb V[\varepsilon_t]$ fixe dans le temps) ou en faisant des régressions linéaires par morceaux ($\mathbb V[\varepsilon_t]$ varie par sous-période).

Ce qui correspont à deux fonctions différentes dans le package : respectivement `piece_reg` et `bp.lms`.

. . .

Concentration plutôt sur `piece_reg` car donne une seule régression en sortie, contrairement à `bp.lms`.

Les estimations de coefficients restent les mêmes. Les seuls changements peuvent survenir sur la variance des sous-modèles qui peut différer de la variance du modèle d'ensemble. Et sur les estimations en temps réel.

##

Avantages :

-   Simples à comprendre et à implémenter

-   Facilement combinable avec d'autres types de modèles (régressions locales)

. . . 

Inconvénients :

-   Suppose l'existence une rupture brutale

-   Imprécisions dans le choix de la date

. . .

Dans le cas de notre modèle exemple, Bai et Perron détecte deux ruptures en 2006 Q2 et 2011 Q2. Pour simplifier les explications on ne retiendra que la deuxième. Le modèle suivant est alors estimé :

$$
PIB_t = (\beta_{0,t}+ \beta_{1,t}climat\_fr_t + \beta_{2,t} \Delta climat\_fr_t) \mathbb{1} _{t \leq 2011.25} +
\\
(\beta_{0,t} + \beta_{1,t} climat\_fr_t + \beta_{2,t} \Delta climat\_fr_t) 1_{t > 2011.25} + \epsilon_t 
$$

##

```{r}
readRDS("graphs_atelier/plot_piecelm.RDS")
```

## 

```{r}
readRDS("graphs_atelier/oos_piecelm.RDS")
```

## Régressions locales

Package `tvreg`

Hypothèse $\beta_t = \beta(z_t)$ avec par défaut $z_t = t/T$.

Et on suppose $\beta()$ localement constante (Nadaraya-Watson) ou localement linéaire.

. . .

Estimation :

$$
\beta(z_t) = \underset{\theta_0}{\argmin}\sum_{j=1}^T\left(y_{j}-x_j\theta_0\right)^2K_b(z_j-z_t)
$$

Avec $K_b(x)=\frac 1 b K(x/b)$ une fonction de noyau pour pondérer les observations.

. . .

Remarque :

-   Problème du choix de $b$ : par validation croisée mais peu discriminant

-   Si $b\geq1$ on utilise toutes les données pour chaque estimation.

-   Si $b=20$ le poids donné à toutes les données se rapproche de 1, estimation $\simeq$ à la régression linéaire

## 

![Noyau en fonction de b](graphs_atelier/test.gif){fig-align="center"}

##

Inconvénient :

-   Tous les coefficients varient

-   Fortes révisions possibles en temps-réel : ajout d'un point, changement de b, noyau asymétrique

. . .

Remarque :

-   Possibilité de combiner les précédents modèles en runant une régression locale sur des données coupées selon Bai et Perron

-   Grâce à des paramètres ou fonctions, on peut fixer les coefficients de certaines variables. Egalement possible pour les régression par morceau.

##

```{r}
readRDS("graphs_atelier/plot_tvlm.RDS")
```

## 

```{r}
readRDS("graphs_atelier/oos_tvlm.RDS")
```

##

```{r}
readRDS("graphs_atelier/plot_coef_tvlm.RDS")
```


## Modèles espace-état

Modélisation espace-état est une méthodologie générale qui permet de traiter un grand nombre de problèmes de séries temporelle.

. . .

On suppose que le problème est déterminé par une série de vecteurs *non observés* $\alpha_1,\dots,\alpha_n$ associés aux observations $y_1,\dots,y_n$, la relation entre $\alpha_t$ et $y_t$ étant spécifiée par le modèle espace-état.

. . .

Plusieurs formes de modèles sont possibles, les plus simples étant les modèles linéaires gaussiens. Nous utilisons une version simplifiée sous la forme :

. . .

$$
\begin{cases}
y_t=X_t\alpha_t+\varepsilon_t,\quad&\varepsilon_t\sim\mathcal N(0,\sigma^2)\\
\alpha_{t+1}=\alpha_t+\eta_t,\quad&\eta_t\sim\mathcal N(0,\sigma^2 Q)
\end{cases},\text{ avec }\eta_t\text{ et }\varepsilon_t\text{ indépendants}
$$

avec $y_t$ de dimension $p\times 1$ vecteur des observations, et $\alpha_t$ de dimension $m \times 1$ vecteur d'états (*state vector*). Et $\sigma^2$ un facteur simplifiant les estimations.

. . .

La première équation est l'équation d'observation (*observation equation*) et la seconde l'équation d'état (*state equation*).

## 

Pour simplifier les calculs et les rendre plus rapide (sutout en présence de beaucoup de données), cette méthode utilise certaines techniques permettant d'estimer tous les paramètres de manière dynamique, comme le filtre de Kalman.

. . .

Deux opérations classiques : *filtering* et *smoothing*

-   Smoothing : estime le coefficient à chaque date grâce à toute l'information disponible. Ce qui est proche des estimations dans l'échantillon.

$$
\hat\alpha_t = E[\alpha_t|y_0, \dots, y_n]
$$

. . . 

-   Filtering : estime le coefficient suivant (en $t+1$) avec les informations connues en t. Ce qui est proche des estimations en temps-réel.

$$
a_{t+1} = E[\alpha_{t+1}|y_0, \dots, y_t]
$$

##

```{r}
readRDS("graphs_atelier/plot_ssm.RDS")
```

## 

```{r}
readRDS("graphs_atelier/oos_ssm.RDS")
```

##

```{r}
#| layout: [[50, 50], [50, 50]]
#| fig-height: 3.5
readRDS("graphs_atelier/plot_intercept.RDS")
readRDS("graphs_atelier/plot_climat.RDS")
readRDS("graphs_atelier/plot_diff.RDS")
```



## Résultats

Etude de 25 modèles de prévision de la production manufacturière estimés entre 1990 Q1 et 2019 Q4. On estime les différents modèles présentés dans l'échantillon et en temps réel, puis on compare les RMSE des modèles par rapport au modèle linéaire. Enfin on fait des moyennes par secteur.

. . . 

On obtient les résultats suivants pour les estimations dans l'échantillon :  

```{r}
library(DT)
library(knitr)
library(kableExtra)
stat_is <- readRDS("graphs_atelier/stats_is.RDS")
stat_is <- round(stat_is, digits = 2)
rownames(stat_is) <- paste(rownames(stat_is), c("(7)","(5)","(5)","(5)","(3)"))
stat_is <- stat_is[,c(2:6)]
kableExtra::kable(stat_is) %>% 
  kable_styling(bootstrap_options = c("condensed", "hover"), 
                position = "center",
                full_width = F) %>% 
  kable_classic()
```

. . . 

La plupart des modèles sont généralement meilleurs que le modèle linéaire.  

##

Et en temps réel : 

```{r}
stat_oos <- readRDS("graphs_atelier/stats_oos.RDS")
stat_oos <- round(stat_oos, digits = 2)
rownames(stat_oos) <- paste(rownames(stat_oos), c("(7)","(5)","(5)","(5)","(3)"))
stat_oos <- stat_oos[,c(2:6)]
kableExtra::kable(stat_oos) %>% 
  kable_styling(bootstrap_options = c("condensed", "hover"), 
                position = "center",
                full_width = F) %>% 
  kable_classic()
```

. . . 

Les modèles espace-état sont meilleurs que le modèle linéaire en terme de RMSE pour la prévision en temps réel. Pour ce qui est des autres modèles, plus variable d'un modèle à l'autre.

##

```{r}
readRDS("graphs_atelier/plot_previsions.RDS")
```

## Conclusion

- Plusieurs types de modèles, avec plusieurs options, se basant sur la régression linéaire

- Tout ce qui a été présenté peut être reproduit grâce au package `tvCoef` qui sera plus développé lors de la partie pratique. 


##

TODO:

- TODO Alain + SSM

- Conclusion + parler du package

- Développer plus sur les résultats ?

- Relire TP / Slides

- Revoir plan ?

- dire que par défaut noyau triweight
$$
\kappa(x)=\frac{35}{32}\left(
  1-
  \left\lvert
  x
  \right\lvert^2
\right)^3 \mathbb 1_{|x| \leq 1}
$$





